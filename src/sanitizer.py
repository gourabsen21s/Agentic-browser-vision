import re
import ast
import logging
from typing import Optional

# Configure logging
logger = logging.getLogger(__name__)

try:
    import autopep8
except ImportError:
    logger.warning("autopep8 not installed. Code formatting features will be disabled.")
    autopep8 = None

class SanitizationError(Exception):
    """Custom exception for code sanitization failures."""
    pass

class CodeSanitizer:
    """
    Responsible for cleaning, formatting, and validating Python code generated by LLMs.
    """

    @staticmethod
    def extract_code_block(llm_output: str) -> str:
        """
        Extracts the first valid Python code block from Markdown.
        
        Handles:
        - ```python code ```
        - ``` code ```
        - Raw code (fallback)
        """
        # 1. Try finding a specifically tagged python block
        python_pattern = r"```python\n(.*?)```"
        match = re.search(python_pattern, llm_output, re.DOTALL | re.IGNORECASE)
        if match:
            return match.group(1)

        # 2. Try finding a generic code block (if the LLM forgot 'python')
        generic_pattern = r"```\n(.*?)```"
        match = re.search(generic_pattern, llm_output, re.DOTALL)
        if match:
            return match.group(1)

        # 3. Fallback: If no markdown formatting found, assume the whole text is code
        # But we strip any leading/trailing backticks just in case
        clean_text = llm_output.strip()
        if clean_text.startswith("```") and clean_text.endswith("```"):
            return clean_text.strip("`")
        
        return clean_text

    @staticmethod
    def format_code(code: str) -> str:
        """
        Uses autopep8 to fix indentation and formatting issues.
        Aggressive level 1 fixes most common whitespace errors.
        """
        if not autopep8:
            return code.strip()

        try:
            # aggressive=1 fixes indentation and whitespace consistency
            formatted_code = autopep8.fix_code(code, options={'aggressive': 1})
            return formatted_code.strip()
        except Exception as e:
            logger.warning(f"Auto-formatting failed: {e}. Returning original code.")
            return code.strip()

    @staticmethod
    def validate_syntax(code: str) -> None:
        """
        Parses the code into an AST to check for syntax errors.
        Raises SyntaxError if invalid.
        """
        try:
            ast.parse(code)
        except SyntaxError as e:
            # Re-raise with a clear message including line number
            raise SanitizationError(f"Syntax Error on line {e.lineno}: {e.msg}")
        except Exception as e:
            raise SanitizationError(f"Code validation failed: {str(e)}")

    @classmethod
    def sanitize(cls, llm_output: str) -> str:
        """
        Orchestrates the full sanitization pipeline.
        Returns clean, runnable Python code or raises SanitizationError.
        """
        # 1. Extract
        raw_code = cls.extract_code_block(llm_output)
        if not raw_code:
            raise SanitizationError("No code block found in LLM output.")

        # 2. Format
        formatted_code = cls.format_code(raw_code)

        # 3. Validate
        cls.validate_syntax(formatted_code)

        return formatted_code